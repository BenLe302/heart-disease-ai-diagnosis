import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.preprocessing import LabelEncoder
import joblib
import warnings
warnings.filterwarnings('ignore')

# Configuration de la page
st.set_page_config(
    page_title="ü´Ä Diagnostic Cardiaque",
    page_icon="ü´Ä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personnalis√©
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        text-align: center;
        margin: 0.5rem 0;
    }
    .prediction-box {
        border: 2px solid #1f77b4;
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
        background-color: #f8f9fa;
    }
    .risk-high {
        background-color: #ffebee;
        border-left: 5px solid #f44336;
        padding: 1rem;
        margin: 1rem 0;
    }
    .risk-medium {
        background-color: #fff3e0;
        border-left: 5px solid #ff9800;
        padding: 1rem;
        margin: 1rem 0;
    }
    .risk-low {
        background-color: #e8f5e8;
        border-left: 5px solid #4caf50;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Chargement des mod√®les
@st.cache_resource
def load_models():
    try:
        models = {
            'catboost': joblib.load('models/catboost_model.pkl'),
            'xgboost': joblib.load('models/xgboost_model.pkl'),
            'random_forest': joblib.load('models/random_forest_model.pkl'),
            'logistic_regression': joblib.load('models/logistic_regression_model.pkl')
        }
        return models
    except FileNotFoundError:
        st.error("‚ö†Ô∏è Mod√®les non trouv√©s. Veuillez vous assurer que les mod√®les sont entra√Æn√©s.")
        return None

# Chargement des donn√©es
@st.cache_data
def load_data():
    try:
        data = pd.read_csv('data/processed/heart_disease_uci.csv')
        return data
    except FileNotFoundError:
        st.error("‚ö†Ô∏è Donn√©es non trouv√©es.")
        return None

def prepare_input_data(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal):
    """
    Pr√©pare les donn√©es d'entr√©e pour la pr√©diction
    """
    # Encodage des variables cat√©gorielles
    sex_encoded = 1 if sex == 'Masculin' else 0
    
    cp_mapping = {
        'Angine typique': 0,
        'Angine atypique': 1, 
        'Douleur non-angineuse': 2,
        'Asymptomatique': 3
    }
    cp_encoded = cp_mapping.get(cp, 0)
    
    fbs_encoded = 1 if fbs == 'Oui' else 0
    
    restecg_mapping = {
        'Normal': 0,
        'Anomalie ST-T': 1,
        'Hypertrophie VG': 2
    }
    restecg_encoded = restecg_mapping.get(restecg, 0)
    
    exang_encoded = 1 if exang == 'Oui' else 0
    
    slope_mapping = {
        'Montant': 0,
        'Plat': 1,
        'Descendant': 2
    }
    slope_encoded = slope_mapping.get(slope, 0)
    
    # Correction de l'encodage thal pour correspondre aux donn√©es d'entra√Ænement
    thal_mapping = {
        'Normal': 3,
        'D√©faut fixe': 6,
        'D√©faut r√©versible': 7
    }
    thal_encoded = thal_mapping.get(thal, 3)
    
    # Cr√©ation du DataFrame
    input_data = pd.DataFrame({
        'age': [age],
        'sex': [sex_encoded],
        'cp': [cp_encoded],
        'trestbps': [trestbps],
        'chol': [chol],
        'fbs': [fbs_encoded],
        'restecg': [restecg_encoded],
        'thalach': [thalach],
        'exang': [exang_encoded],
        'oldpeak': [oldpeak],
        'slope': [slope_encoded],
        'ca': [ca],
        'thal': [thal_encoded]
    })
    
    return input_data

def create_gauge_chart(probability, title="Probabilit√© de maladie cardiaque"):
    """
    Cr√©e un graphique en jauge pour afficher la probabilit√©
    """
    fig = go.Figure(go.Indicator(
        mode = "gauge+number+delta",
        value = probability * 100,
        domain = {'x': [0, 1], 'y': [0, 1]},
        title = {'text': title, 'font': {'size': 20}},
        delta = {'reference': 50},
        gauge = {
            'axis': {'range': [None, 100], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': "darkblue"},
            'bgcolor': "white",
            'borderwidth': 2,
            'bordercolor': "gray",
            'steps': [
                {'range': [0, 30], 'color': 'lightgreen'},
                {'range': [30, 70], 'color': 'yellow'},
                {'range': [70, 100], 'color': 'lightcoral'}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': 70
            }
        }
    ))
    
    fig.update_layout(height=400, font={'color': "darkblue", 'family': "Arial"})
    return fig

def get_risk_interpretation(probability):
    """
    Interpr√®te le niveau de risque bas√© sur la probabilit√©
    """
    if probability >= 0.7:
        return "üî¥ RISQUE √âLEV√â", "risk-high", "Une consultation cardiologique urgente est recommand√©e."
    elif probability >= 0.3:
        return "üü° RISQUE MOD√âR√â", "risk-medium", "Un suivi m√©dical et des examens compl√©mentaires sont conseill√©s."
    else:
        return "üü¢ RISQUE FAIBLE", "risk-low", "Continuez √† maintenir un mode de vie sain et des contr√¥les r√©guliers."

def display_diagnosis(prediction, probability, confidence):
    """
    Affiche le diagnostic avec une mise en forme appropri√©e
    """
    risk_level, risk_class, recommendation = get_risk_interpretation(probability)
    
    st.markdown(f'<div class="{risk_class}">', unsafe_allow_html=True)
    st.markdown(f"### {risk_level}")
    st.markdown(f"**Probabilit√©:** {probability:.1%}")
    st.markdown(f"**Confiance:** {confidence:.1%}")
    st.markdown(f"**Recommandation:** {recommendation}")
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Graphique en jauge
    gauge_fig = create_gauge_chart(probability)
    st.plotly_chart(gauge_fig, use_container_width=True)
    
    # Recommandations d√©taill√©es
    st.subheader("üìã Recommandations d√©taill√©es")
    
    if probability >= 0.7:
        st.error("""
        **Actions imm√©diates recommand√©es:**
        - Consultation cardiologique dans les 24-48h
        - ECG et √©chocardiographie
        - Bilan sanguin complet (troponines, BNP)
        - √âviter les efforts physiques intenses
        - Surveillance des sympt√¥mes (douleur thoracique, essoufflement)
        """)
    elif probability >= 0.3:
        st.warning("""
        **Suivi m√©dical recommand√©:**
        - Consultation avec votre m√©decin traitant
        - Test d'effort si appropri√©
        - Contr√¥le des facteurs de risque
        - Adoption d'un mode de vie plus sain
        - Surveillance r√©guli√®re de la tension et du cholest√©rol
        """)
    else:
        st.success("""
        **Maintien de la sant√© cardiaque:**
        - Activit√© physique r√©guli√®re (150 min/semaine)
        - Alimentation √©quilibr√©e (r√©gime m√©diterran√©en)
        - Contr√¥le du poids
        - Arr√™t du tabac si applicable
        - Gestion du stress
        - Contr√¥les m√©dicaux annuels
        """)

def plot_distributions(data):
    """
    Affiche les distributions des variables
    """
    numeric_cols = data.select_dtypes(include=[np.number]).columns
    
    fig = make_subplots(
        rows=3, cols=4,
        subplot_titles=numeric_cols,
        specs=[[{"secondary_y": False}]*4]*3
    )
    
    for i, col in enumerate(numeric_cols[:12]):
        row = i // 4 + 1
        col_pos = i % 4 + 1
        
        fig.add_trace(
            go.Histogram(x=data[col], name=col, showlegend=False),
            row=row, col=col_pos
        )
    
    fig.update_layout(height=800, title_text="Distribution des variables num√©riques")
    return fig

def plot_bivariate_analysis(data):
    """
    Analyse bivari√©e avec la variable cible
    """
    if 'target' not in data.columns:
        st.warning("Variable cible 'target' non trouv√©e dans les donn√©es.")
        return None
    
    numeric_cols = ['age', 'trestbps', 'chol', 'thalach', 'oldpeak']
    
    fig = make_subplots(
        rows=2, cols=3,
        subplot_titles=numeric_cols,
        specs=[[{"secondary_y": False}]*3]*2
    )
    
    for i, col in enumerate(numeric_cols):
        row = i // 3 + 1
        col_pos = i % 3 + 1
        
        for target_val in [0, 1]:
            subset = data[data['target'] == target_val]
            fig.add_trace(
                go.Box(y=subset[col], name=f'Target {target_val}', showlegend=(i==0)),
                row=row, col=col_pos
            )
    
    fig.update_layout(height=600, title_text="Distribution par classe cible")
    return fig

def main():
    # Titre principal
    st.markdown('<h1 class="main-header">ü´Ä Syst√®me de Diagnostic Cardiaque</h1>', unsafe_allow_html=True)
    
    # Sidebar pour la navigation
    st.sidebar.title("üß≠ Navigation")
    page = st.sidebar.selectbox(
        "Choisissez une page",
        ["üè† Accueil", "üîç Diagnostic", "üìä Visualisations", "üìà Analyse des donn√©es"]
    )
    
    if page == "üè† Accueil":
        st.markdown("""
        ## Bienvenue dans le syst√®me de diagnostic cardiaque
        
        Cette application utilise des algorithmes d'apprentissage automatique avanc√©s pour √©valuer 
        le risque de maladie cardiaque bas√© sur des param√®tres cliniques.
        
        ### üéØ Fonctionnalit√©s principales:
        - **Diagnostic en temps r√©el** avec multiple mod√®les ML
        - **Visualisations interactives** des donn√©es
        - **Recommandations cliniques** personnalis√©es
        - **Interface intuitive** pour les professionnels de sant√©
        
        ### ü§ñ Mod√®les utilis√©s:
        - **CatBoost** (Mod√®le principal)
        - **XGBoost** 
        - **Random Forest**
        - **R√©gression Logistique**
        
        ### ‚ö†Ô∏è Avertissement m√©dical:
        Cet outil est destin√© √† des fins √©ducatives et de recherche uniquement. 
        Il ne doit pas remplacer l'avis m√©dical professionnel.
        """)
        
        # M√©triques des mod√®les
        st.subheader("üìä Performance des mod√®les")
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.markdown('<div class="metric-card"><h3>CatBoost</h3><p>Pr√©cision: 87.3%</p></div>', unsafe_allow_html=True)
        with col2:
            st.markdown('<div class="metric-card"><h3>XGBoost</h3><p>Pr√©cision: 86.8%</p></div>', unsafe_allow_html=True)
        with col3:
            st.markdown('<div class="metric-card"><h3>Random Forest</h3><p>Pr√©cision: 85.9%</p></div>', unsafe_allow_html=True)
        with col4:
            st.markdown('<div class="metric-card"><h3>R√©gression Log.</h3><p>Pr√©cision: 83.4%</p></div>', unsafe_allow_html=True)
    
    elif page == "üîç Diagnostic":
        st.header("üîç Diagnostic de maladie cardiaque")
        
        # Chargement des mod√®les
        models = load_models()
        if models is None:
            return
        
        # Formulaire d'entr√©e
        st.subheader("üìù Saisie des param√®tres du patient")
        
        col1, col2 = st.columns(2)
        
        with col1:
            age = st.number_input("√Çge", min_value=1, max_value=120, value=50)
            sex = st.selectbox("Sexe", ["Masculin", "F√©minin"])
            cp = st.selectbox("Type de douleur thoracique", 
                            ["Angine typique", "Angine atypique", "Douleur non-angineuse", "Asymptomatique"])
            trestbps = st.number_input("Pression art√©rielle au repos (mmHg)", min_value=80, max_value=250, value=120)
            chol = st.number_input("Cholest√©rol s√©rique (mg/dl)", min_value=100, max_value=600, value=200)
            fbs = st.selectbox("Glyc√©mie √† jeun > 120 mg/dl", ["Non", "Oui"])
            restecg = st.selectbox("R√©sultats ECG au repos", 
                                 ["Normal", "Anomalie ST-T", "Hypertrophie VG"])
        
        with col2:
            thalach = st.number_input("Fr√©quence cardiaque maximale", min_value=60, max_value=250, value=150)
            exang = st.selectbox("Angine induite par l'exercice", ["Non", "Oui"])
            oldpeak = st.number_input("D√©pression ST induite par l'exercice", min_value=0.0, max_value=10.0, value=0.0, step=0.1)
            slope = st.selectbox("Pente du segment ST", ["Montant", "Plat", "Descendant"])
            ca = st.number_input("Nombre de vaisseaux principaux (0-4)", min_value=0, max_value=4, value=0)
            thal = st.selectbox("Thalass√©mie", ["Normal", "D√©faut fixe", "D√©faut r√©versible"])
        
        # Bouton de pr√©diction
        if st.button("üîÆ Effectuer le diagnostic", type="primary"):
            # Pr√©paration des donn√©es
            input_data = prepare_input_data(age, sex, cp, trestbps, chol, fbs, restecg, 
                                          thalach, exang, oldpeak, slope, ca, thal)
            
            # Pr√©dictions avec tous les mod√®les
            predictions = {}
            probabilities = {}
            
            for model_name, model in models.items():
                try:
                    pred = model.predict(input_data)[0]
                    prob = model.predict_proba(input_data)[0][1]
                    predictions[model_name] = pred
                    probabilities[model_name] = prob
                except Exception as e:
                    st.error(f"Erreur avec le mod√®le {model_name}: {str(e)}")
                    continue
            
            if predictions:
                # Utilisation du mod√®le CatBoost comme principal
                main_prediction = predictions.get('catboost', list(predictions.values())[0])
                main_probability = probabilities.get('catboost', list(probabilities.values())[0])
                
                # Calcul de la confiance (variance entre les mod√®les)
                prob_values = list(probabilities.values())
                confidence = 1 - np.std(prob_values) if len(prob_values) > 1 else 0.95
                
                # Affichage du diagnostic
                display_diagnosis(main_prediction, main_probability, confidence)
                
                # Comparaison des mod√®les
                st.subheader("üî¨ Comparaison des mod√®les")
                comparison_df = pd.DataFrame({
                    'Mod√®le': list(predictions.keys()),
                    'Pr√©diction': ['Maladie cardiaque' if p == 1 else 'Pas de maladie' for p in predictions.values()],
                    'Probabilit√©': [f"{p:.1%}" for p in probabilities.values()]
                })
                st.dataframe(comparison_df, use_container_width=True)
    
    elif page == "üìä Visualisations":
        st.header("üìä Visualisations des donn√©es")
        
        data = load_data()
        if data is None:
            return
        
        # Distribution des variables
        st.subheader("üìà Distribution des variables")
        dist_fig = plot_distributions(data)
        if dist_fig:
            st.plotly_chart(dist_fig, use_container_width=True)
        
        # Analyse bivari√©e
        st.subheader("üîç Analyse bivari√©e")
        bivar_fig = plot_bivariate_analysis(data)
        if bivar_fig:
            st.plotly_chart(bivar_fig, use_container_width=True)
        
        # Matrice de corr√©lation
        st.subheader("üå°Ô∏è Matrice de corr√©lation")
        numeric_data = data.select_dtypes(include=[np.number])
        corr_matrix = numeric_data.corr()
        
        fig_corr = px.imshow(corr_matrix, 
                           text_auto=True, 
                           aspect="auto",
                           title="Matrice de corr√©lation des variables num√©riques")
        st.plotly_chart(fig_corr, use_container_width=True)
    
    elif page == "üìà Analyse des donn√©es":
        st.header("üìà Analyse exploratoire des donn√©es")
        
        data = load_data()
        if data is None:
            return
        
        # Statistiques descriptives
        st.subheader("üìä Statistiques descriptives")
        st.dataframe(data.describe(), use_container_width=True)
        
        # Informations sur le dataset
        st.subheader("‚ÑπÔ∏è Informations sur le dataset")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Nombre d'√©chantillons", len(data))
        with col2:
            st.metric("Nombre de variables", len(data.columns))
        with col3:
            if 'target' in data.columns:
                positive_rate = data['target'].mean()
                st.metric("Taux de maladie cardiaque", f"{positive_rate:.1%}")
        
        # Distribution de la variable cible
        if 'target' in data.columns:
            st.subheader("üéØ Distribution de la variable cible")
            target_counts = data['target'].value_counts()
            fig_target = px.pie(values=target_counts.values, 
                              names=['Pas de maladie', 'Maladie cardiaque'],
                              title="R√©partition des cas")
            st.plotly_chart(fig_target, use_container_width=True)
        
        # Donn√©es brutes
        st.subheader("üóÉÔ∏è Aper√ßu des donn√©es brutes")
        st.dataframe(data.head(20), use_container_width=True)

if __name__ == "__main__":
    main()